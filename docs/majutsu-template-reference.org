#+title: Majutsu Template Reference

* Types
需要支持强类型检查

** 对象方法
对象只能使用在定义中声明过的对应类型对应的方法

** Conversion
这是一个简陋的变量隐式转换系统
只支持 各种类型到 Boolean Serialize Template 三种类型的转化

这里实现上就把到 B S T 三种类型的类型统一放在某个表里
然后判断的时候查表就好了
可以在这些函数定义的时候收集这个信息

** 实现细节

我需要实现的其实只有从 Template (对应我写在 elisp 代码里的最基础的形式) 到各种类型的转化？

*** Boolean
[[file:template_help.md::`Boolean` type]]
t -> true
nil -> false

*** Integer
[[file:template_help.md::`Integer` type]]

elisp 中的数字需要能隐式转换为 Integer or String
通过参数能接受的类型选择

*** String
[[file:template_help.md::`String` type]]

elisp 中的字符串自动转换为 String type

它非常符合直觉所以之后作为基本的写法

*** raw
这是 EDSL 特有的类型，用来直接注入
~'quote~ 等效于 ~[:raw "quote"]~
如果想要包含括号，需要写成 ~(intern "test()")~
用反斜杠转义也行 ~'test\(\)~

会直接跳过相关的类型检查
如果需要，希望可以手动设定类型，作为第二个参数

可能被用来表示为暂未实现的函数或对象名

*** Template
[[file:template_help.md::`Template` type]]
它表示的是整个模板最后的输出的类型

大多数类型可以隐式转换为 Template

*** Stringify
[[file:template_help.md::`Stringify` type]]
删去了 color label 的 [[Template]]
本质上是一个隐式转换（我们不用管）

*** Trailer
[[file:template_help.md::`Trailer` type]]

这应该是一个挺重要的类型

* Functions
除了原生的模板语言的内置函数，我还希望能定义一些用宏实现的自定义函数（或方法）

需要支持返回值作为它作为其他函数参数时的类型

** 原语 raw
仅有 ~[:raw "string"]~ 为 [[raw]] type

** 类型声明
~[:Template "string"]~ => ~[:raw "template" :Template]~

** self 对象
我们默认 self 对象为函数的第一个参数
可以没有参数

** 函数调用
~[:call 'FUN args]~
=> ~[:raw "FUN(arg1, arg2, ...)"]~

一般来说可写为 ~[:FUN args]~

** 方法调用
~[:method 'OBJ :FUN args]~

连续调用：
~[:method 'OBJ :FUN1 arg1 arg2 ... :FUN2 args2]~
要能支持 &arg 的多参数收集，当然是取到下一个 :FUN 前

~:.~ 应该被认为等同于 ~:method~

可以用 ~[:change_id]~ 的形式来统一表示对象属性，因为它统一了成员和方法的表示

对于 ~[:FUN args]~
- 如果 :FUN 是全局、内置函数，就给全局函数
- 如果 :FUN 是 self 的方法，直接扩展为 ~[:method 'self :FUN args]~
  若匹配上了，我们称它为关键字
  这里有一个细节，我们默认一个函数的第一个参数是 self 变量
  我们需要替换成的是 self 变量对应的字面值，不是直接替换成 'self
- 如果都不是，报错，提示找不到 OBJ

*** 关键字
关键字是对于 self 对象的 0参数 方法的简化写法，可以省去 self. 和 ()

这个语言本来提供了一个不用方法而用关键字的语法糖，我认为这个语法糖还不够彻底
（函数定义里没有这个功能，只有命令直接调用的时候有）

我们可以把关键字体现在字面量上
比如说对于 ~'change_id~ 我们完全可以先尝试让他作为 ~[:change_id]~ 的形式看看能不能匹配成关键字
（前两步一致，最后一步是用无类型的 raw 为 fallback，当然警告也要警告）


** concat 语法糖
~["X" "Y"]~ => ~[:concat "X" "Y"]~
这里要求向量中的每一项都能转换为 Template
一般来说只需要看第一项的类型就行

也支持把 ~:concat~ 写成 ~:++~

** List related
~.filter(|item| expression) -> List~: Filter list elements by predicate
 `expression`. Example: `description.lines().filter(|s| s.contains("#"))`
 
~.map(|item| expression) -> ListTemplate~: Apply template `expression`
 to each element. Example: `parents.map(|c| c.commit_id().short())`
 
~.any(|item| expression) -> Boolean~: Returns true if any element satisfies
 the predicate `expression`. Example: `parents.any(|c| c.description().contains("fix"))`
 
~.all(|item| expression) -> Boolean~: Returns true if all elements satisfy
 the predicate `expression`. Example: `parents.all(|c| c.mine())`
 
这个东西如何处理？其实就是嵌了个匿名函数进去

重点是如何做到不强制嵌入匿名函数
目前 list 相关的函数的功能还是比较少的，但是我们应该考虑一下扩展性

因为最后他的输出会被拍扁，所以显然这是可行的

*** 匿名函数 with binding
还是需要支持绑定参数的形式，不然不好嵌套

对于正常的 ~:map~
它和一般的成员函数无异，只是接受的是一个匿名函数

使用 - 开头的函数表示支持形似 ~(-map FN LIST)~ 的语法

这和前面定义的 OBJ 前置有点不一样，
但是为了和 elisp 的统一，我觉得有必要搞一个反序的形式

一个例子
~[:-map [:lambda [c] [:method 'c :description]] [:added_targets]]~
=> ~[:method [:added_targets] :map [:lambda [c] [:method 'c :description]]]~

注意这里不能省略 :method ，因为这里父亲的 self 对象依然存在！
只有完全单独定义的函数可以应用这个语法糖

*** 匿名函数 without binding
一些简单的函数就不需要写 binding 了
可以完美对应上
fn:--map
fn:--filter
fn:--any
fn:--all-p

例子：
~[:--map [:method 'it :description] [:added_targets]]~

需要借鉴 dash.el 的处理
内层 it 会遮蔽外层 it

** 自定义函数
*** 定义宏
宏 ~majutsu-template-defun~ 会在定义阶段完成两件事：
1. 生成一个 ~majutsu-template-NAME~ 的 Elisp 函数，调用前会先对参数做 normalize（向量 → AST、字符串 → ~:str~），再执行主体，最后再 normalize 返回值。
2. 同时把函数的元数据写入注册表：
   读取参数列表 ~(:returns TYPE …)~
   可选的 ~:scope~/~:owner~/~:template-name~，构造成 ~majutsu-template--fn~ 记录。
   普通函数注册到全局函数表；
   ~:scope :method~ 或 ~:keyword~ 会登记到 ~(TYPE . name)~ 的方法表。

参数声明使用 ~(arg TYPE [:optional t] [:rest t] [:converts LIST])~ 形式；宏在宏展开期解析这些信息，自动拼好 ~lambda-list~ 与 docstring。

方法/关键字可以通过 ~majutsu-template-defmethod~、~majutsu-template-defkeyword~ 封装，或在常量表里批量声明。

*** 匿名函数
~[:lambda [c] BODY]~

或多变量的形式
~[:lambda [a b c] BODY]~
我觉得可能不太好处理，可能之后再支持

一般来说单个变量的用的比较多
设置一个 ~[:+ARG BODY]~ 的语法糖
相当于 ~[:lambda [ARG] BODY]~

需要一个和 :call 配合的语法糖
~[[:lambda [c] BODY] arg]~
等效于
~[:call [:lambda [c] BODY] arg]~

*** 顶层函数
- 使用 ~majutsu-template-defun~ 定义模板函数时，宏会同时生成 Elisp 实现与元数据；在 ~majutsu-template.el~ 内置函数也通过常量表注册。
- 类型签名写为 ~(:returns TYPE ...)~；额外的 [:scope] 和 [:owner] 只在方法/关键字定义时需要，keyword 与 method 共享同一注册表。
- 方法和关键字使用 ~majutsu-template-defmethod~ / ~majutsu-template-defkeyword~，或者在常量 ~majutsu-template--builtin-method-specs~ 里声明；都会展开成带 self 的参数列表并登记类型。
- 内建类型通过 ~majutsu-template-define-type~ 录入，含 ~:doc~ 与 ~:converts~ 信息；支持 ~((Type . status))~、符号或列表等多种写法，宏会统一成 `(TYPE . (yes|no|maybe))`。

* 嵌入 Emacs Lisp
这是非常重要的功能

** 直接嵌入
直接嵌入的 consp 形式需要在宏展开时运行

比如：
~[(if "A" "B") (if t "C" "D")]~
我想要得到的是
~[:concat "A" "C"]~

** 反引号插入
回引号 + 逗号插入已计算的节点：
- ~(let ((name (majutsu-template-str (user-full-name))))
    (tpl-compile `[:concat ,name [:str ": "] [:raw "self.commit_id()"]]))~
    
批量插入：
- ~(let ((items (mapcar #'majutsu-template-str '("A" "B"))))
    (tpl-compile `[:concat ,@items]))~
    
* 哪些命令的输出可以使用 template ?
| command        | self type            |
|----------------+----------------------|
| bookmark list  | CommitRef            |
| diff           | TreeDiffEntry        |
| evolog         | CommitEvolutionEntry |
| file annotate  | AnnotationLine       |
| flie list      | TreeEntry            |
| flie show      | TreeEntry            |
| log            | Commit               |
| op log         | Operation            |
| op show        | Operation            |
| show           | Commit               |
| tag list       | CommitRef            |
| workspace list | WorkspaceRef         |
| config list    | [[config list template]] |


** config list template

我们可以因此建一个 Config type

name: String: Config name.
value: ConfigValue: Value to be formatted in TOML syntax.
overridden: Boolean: True if the value is shadowed by other.
source: String: Source of the value.
path: String: Path to the config file.
