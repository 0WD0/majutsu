#+title: Majutsu Specifications

拉到本地到 org-mode 中阅读能获得更好的阅读体验

* Majutsu Buffers
** majutsu-log
这是我们主要工作在的buffer
因为不像 git 最常用的是 status，在 jj 中 log 反而是更加常用的命令

*** DONE track current revision
magit log section 需要同时存在 change_id 和 commit_id
这样才能在 squash rebase 等会修改 commit_id 的操作之后才能track到正确的section

这应该是非常重要的功能，
相比之下，默认的跳到 @ 可以直接按 [[kbd:.]] 来实现

当前实现：
fn:majutsu-parse-log-entries 解析 =change_id= 并把它存到 section value 以及 =majutsu-log-entry-section= 的 =change-id= slot 里。
fn:magit-section-ident-value 对 majutsu log entry 以 =change_id= 为主键，fallback 到 =commit_id=。
fn:majutsu-log-refresh 刷新前记录当前 section 的 =change_id=，刷新后优先用 =change_id= 定位，否则退回 =commit_id=，都失败时跳转到 =@=。
fn:majutsu-log--commit-id-at-point 在 =commit_id= 缺失时返回 =change_id=，保证下游命令用的是稳定标识。

*** TODO builtin avy support
由于 change-id 的设计本来就在高亮唯一前缀
我们完全可以用 avy 的模式来进行跳转！

*** 窗口管理
magit 的buffer都是直接占满全屏，我不想要这样的设计。

我认为让一个 jujutsu log buffer 长时间占在一个窗口里是十分常用的状态
（连续多次的 checkout 是正常的操作），
所以我们默认分屏使用

如果当前只有一个窗口，就分一个窗口，退出时恢复为一个窗口；
如果当时有多个窗口，占据除了当前窗口之外的某一个窗口，退出时恢复那个被占据 buffer。

** message buffer

*** TODO 完全使用 with-editor 方案

这是一种完全没有兼容性问题的方案，之后考虑在适当的时候完全转到这个方案上

**** with-editor 文件定位

jj 在需要编辑描述信息的时候，会把待编辑的描述文件放在临时目录 =/tmp/= 下，
命名格式为 =editor-XXXXXX.jjdescription=，其中 =X= 可能是数字、大小写字母混合。
需要以这个模式为依据（正则大致是 =/tmp/editor-[0-9A-Za-z]+\.jjdescription=）
去匹配 =with-editor-server-window-alist=，确保描述文件落回 majutsu 的 log 窗口，
而不是打断用户原本的窗口布局。

*** 窗口管理

在打开 message buffer 的时候有两种状态：
1. 在 log buffer 内
2. 不在 log buffer 内

如果当前只有一个窗口，我们希望分屏

如果有两个，如果另一个不是 log buffer 就用另一个
如果另一个是 log buffer 就用这一个


*** TODO 附加 diff 信息

** diff buffer
目前的实现是直接调用的 diff-mode，需要优化

*** TODO visit
实际上应该使用放在 log buffer 下的
Working Copy Changes section 实现，
这样才能用 fn:magit-visit-thing

然后和 magit 的设计不同，我们在查看一个 rev 的时候如果想要 visit
很有可能是有 edit 到对应 rev 的需求的
可以绑定到 [[kbd:e]]

所以目标设计是有两种 visit
一种是附加 edit 的（并且需要确认）
一种是类似 magit 实现的访问 tmpfile

* Transient Views
** command view
** log view
** squash view
** bookmark view
*** list
**** TODO 高亮显示
**** TODO 支持到跳转焦点到对应的 log view entry
*** move
**** DONE 支持 -B
要把 bookmark 往前移需要设置 --allow-backwards
打算设置到 M 上
** rebase view
** git view

* Operations
** new
需要两种模式
一种是直接在当前 revset 新建
一种是进入一个多选模式，可以 toggle 不同的参数对应的 revset 集
这里可以借鉴 rebase transient 的设计

*** 快捷模式（direct new）
继续复用 ~N~ 键；无前缀时直接在当前光标所在的 changeset 上执行 ~jj new~，选中节点成为默认的唯一父节点。
如果当前无法识别 changeset（例如 log buffer 为空），则 fallback 到 ~@~（working copy）。
~C-u N~ 保留手动选择父节点的行为，提供 bookmark + changeset id 的 completion。
执行成功后刷新 log，并在可能情况下跳回新的 ~@~。

*** Transient 模式（majutsu-new-transient）
- 新增命令 ~majutsu-new-transient~，默认提供在 ~majutsu-mode-transient~ 菜单中；不强绑按键，避免覆盖 ~magit-section~ 的导航键。
- 进入 transient 后沿用 rebase transient 的 overlay 模式，三种状态分别高亮：
  - <REVSETS>：父节点集合，按 ~p~ 在光标处 toggle；使用 ~[PARENT]~ label 及 ~(:background "dark orange" :foreground "black")~。
  - ~-A/--after~：插入位置的父节点，按 ~a~ toggle；使用 ~[AFTER]~ label 及 ~(:background "dark blue" :foreground "white")~。
  - ~-B/--before~：插入位置的子节点（多选），按 ~b~ toggle；使用 ~[BEFORE]~ label 及 ~(:background "dark magenta" :foreground "white")~。
- ~m~ 用于一次性输入提交信息，映射到 ~--message~；~e~ toggle ~--no-edit~。
- ~RET~ 和 ~n~ 触发执行；命令行参数按以下顺序拼装：
  1. <REVSETS> 列表（为空时默认 ~@~）。
  2. 每个 ~-A~ / ~--after~ 目标按选择顺序展开。
  3. 每个 ~-B~ / ~--before~ 目标按选择顺序展开。
  4. 可选的 ~--message~ 与 ~--no-edit~。
- ~c~ 清除所有选择；~q~ 退出时自动清理 overlay 与内部 state。

*** 状态建模
- 维护 ~majutsu-new-parents~、~majutsu-new-after~、~majutsu-new-before~ 三个列表，以及对应 overlay 列表。
- 退出 transient（含执行成功）时统一清理 state。
- 复用 ~majutsu-log--commit-id-at-point~ 判断当前 changeset id，尽量与 rebase transient 的 helper 对齐，必要时抽象通用 overlay 操作。
- 抽取一个 ~majutsu-new--build-args~ 辅助函数，集中拼装命令参数，便于 ERT 覆盖。
- 引入统一的 ~<REFSET>~（单选）与 ~<REFSETS>~（多选） selection helper，命令只需提供 label/face 与 state 变量即可复用。

*** TODO
- 与 rebase transient 共享 overlay/util helper，减少重复逻辑。
- 覆盖以下测试：
  - overlay 状态切换（父/after/before）。
  - ~majutsu-new--build-args~ 参数拼装。
  - ~--no-edit~ 与 ~--message~ 交互路径。

** duplicate
我觉得也挺重要的，需要支持

** split
这是 jj-mode.el 还没有实现的功能，我想要把它实现了

=--tool :builtin=
[[https://github.com/arxanas/scm-record?tab=readme-ov-file#scm-diff-editor][scm-record]] 中的 scm-diff-editor
是jj内置的默认编辑工具

可以参考 [[https://github.com/ilyagr/diffedit3][diffedit3]] 的实现

我觉得我可以解决一次只能 split 一个 rev 的限制！

每个changeset是基于前一个 rev 的

如果设成 =--tool emacs= 在默认下的行为：
他创建了两个临时目录，只包含当前 changeset 涉及到的文件
把当前 changeset 应用前放在了 left 目录里
把当前 changeset 应用后的文件放在了 right 目录里
然后对right修改得到的 changeset，是你想插入的中间的 rev
然后当前 changeset 就是原先 changset 和这个你编辑得到的 changeset 取反

如何设计进行连续的多个 split？
split 产生的 rev 是否必须是一条链？我觉得应该是？
我如何处理树状视图？
