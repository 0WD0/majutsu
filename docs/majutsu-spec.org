#+title: Majutsu Specifications

拉到本地到 org-mode 中阅读能获得更好的阅读体验

* Majutsu Buffers
** majutsu-log
这是我们主要工作在的buffer
因为不像 git 最常用的是 status，在 jj 中 log 反而是更加常用的命令

*** DONE track current revision
magit log section 需要同时存在 change_id 和 commit_id
这样才能在 squash rebase 等会修改 commit_id 的操作之后才能track到正确的section

这应该是非常重要的功能，
相比之下，默认的跳到 @ 可以直接按 [[kbd:.]] 来实现

当前实现：
fn:majutsu-parse-log-entries 解析 =change_id= 并把它存到 section value 以及 =majutsu-log-entry-section= 的 =change-id= slot 里。
fn:magit-section-ident-value 对 majutsu log entry 以 =change_id= 为主键，fallback 到 =commit_id=。
fn:majutsu-log-refresh 刷新前记录当前 section 的 =change_id=，刷新后优先用 =change_id= 定位，否则退回 =commit_id=，都失败时跳转到 =@=。
fn:majutsu-log--commit-id-at-point 在 =commit_id= 缺失时返回 =change_id=，保证下游命令用的是稳定标识。

*** TODO builtin avy support
由于 change-id 的设计本来就在高亮唯一前缀
我们完全可以用 avy 的模式来进行跳转！

*** 窗口管理
magit 的buffer都是直接占满全屏，我不想要这样的设计。

我认为让一个 jujutsu log buffer 长时间占在一个窗口里是十分常用的状态
（连续多次的 checkout 是正常的操作），
所以我们默认分屏使用

如果当前只有一个窗口，就分一个窗口，退出时恢复为一个窗口；
如果当时有多个窗口，占据除了当前窗口之外的某一个窗口，退出时恢复那个被占据 buffer。

** message buffer

*** TODO 完全使用 with-editor 方案

这是一种完全没有兼容性问题的方案，之后考虑在适当的时候完全转到这个方案上

**** with-editor 文件定位

jj 在需要编辑描述信息的时候，会把待编辑的描述文件放在临时目录 =/tmp/= 下，
命名格式为 =editor-XXXXXX.jjdescription=，其中 =X= 可能是数字、大小写字母混合。
需要以这个模式为依据（正则大致是 =/tmp/editor-[0-9A-Za-z]+\.jjdescription=）
去匹配 =with-editor-server-window-alist=，确保描述文件落回 majutsu 的 log 窗口，
而不是打断用户原本的窗口布局。

*** 窗口管理

在打开 message buffer 的时候有两种状态：
1. 在 log buffer 内
2. 不在 log buffer 内

如果当前只有一个窗口，我们希望分屏

如果有两个，如果另一个不是 log buffer 就用另一个
如果另一个是 log buffer 就用这一个


*** TODO 附加 diff 信息

** diff buffer
目前的实现是直接调用的 diff-mode，需要优化

*** TODO visit
实际上应该使用放在 log buffer 下的
Working Copy Changes section 实现，
这样才能用 fn:magit-visit-thing

然后和 magit 的设计不同，我们在查看一个 rev 的时候如果想要 visit
很有可能是有 edit 到对应 rev 的需求的
可以绑定到 [[kbd:e]]

所以目标设计是有两种 visit
一种是附加 edit 的（并且需要确认）
一种是类似 magit 实现的访问 tmpfile

* Transient Views
** command view
** log view
** squash view
** bookmark view
*** list
**** TODO 高亮显示
**** TODO 支持到跳转焦点到对应的 log view entry
*** move
**** DONE 支持 -B
要把 bookmark 往前移需要设置 --allow-backwards
打算设置到 M 上
** rebase view
** git view

* Operations
** new
它的实现方式是比较显然的
参数只有一个 revsets

** duplicate
我觉得也挺重要的，需要支持

** split
这是 jj-mode.el 还没有实现的功能，我想要把它实现了

=--tool :builtin=
[[https://github.com/arxanas/scm-record?tab=readme-ov-file#scm-diff-editor][scm-record]] 中的 scm-diff-editor
是jj内置的默认编辑工具

可以参考 [[https://github.com/ilyagr/diffedit3][diffedit3]] 的实现

我觉得我可以解决一次只能 split 一个 rev 的限制！

每个changeset是基于前一个 rev 的

如果设成 =--tool emacs= 在默认下的行为：
他创建了两个临时目录，只包含当前 changeset 涉及到的文件
把当前 changeset 应用前放在了 left 目录里
把当前 changeset 应用后的文件放在了 right 目录里
然后对right修改得到的 changeset，是你想插入的中间的 rev
然后当前 changeset 就是原先 changset 和这个你编辑得到的 changeset 取反

如何设计进行连续的多个 split？
split 产生的 rev 是否必须是一条链？我觉得应该是？
我如何处理树状视图？
