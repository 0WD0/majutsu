#+title: Majutsu Template Specifications

在查看全文之前应该先对 jujutsu template language 有一定了解。

* 目标
实现一个 jujutsu template 的 elisp DSL

实现一个简单的编译器，编译成果是一个字符串
用来传入 flag -T 的template参数

不需要修改用户配置的可配置模板
DSL

在 Transient View 中

* Types
需要支持强类型检查
TODO: 当前实现尚未在运行时执行类型校验

** 对象方法
对象只能使用在定义中声明过的对应类型对应的方法

** Conversion
这是一个简陋的变量隐式转换系统
只支持 各种类型到 Boolean Serialize Template 三种类型的转化

这里实现上就把到 B S T 三种类型的类型统一放在某个表里
然后判断的时候查表就好了
可以在这些函数定义的时候收集这个信息
TODO: 目前仅登记转换关系，尚未在调用处强制检查

** 实现细节

我需要实现的其实只有从 Template (对应我写在 elisp 代码里的最基础的形式) 到各种类型的转化？

*** raw
这是 EDSL 特有的类型，用来直接注入
~'quote~ 等效于 ~[:raw "quote"]~
如果想要包含括号，需要写成 ~(intern "test()")~
用反斜杠转义也行 ~'test\(\)~

会直接跳过相关的类型检查
如果需要，希望可以手动设定类型，作为第二个参数

可能被用来表示为暂未实现的函数或对象名

*** String
https://github.com/jj-vcs/jj/blob/main/docs/templates.md#string-type

elisp 中的字符串自动转换为 String type

它非常符合直觉所以之后作为基本的写法

*** Boolean
https://github.com/jj-vcs/jj/blob/main/docs/templates.md#boolean-type

t -> true
nil -> false

*** Integer
https://github.com/jj-vcs/jj/blob/main/docs/templates.md#integer-type

elisp 中的数字需要能隐式转换为 Integer or String
通过参数能接受的类型选择

*** Template
https://github.com/jj-vcs/jj/blob/main/docs/templates.md#template-type
它表示的是整个模板最后的输出的类型

这是隐式转换相关的一个重要类型

*** Stringify
https://github.com/jj-vcs/jj/blob/main/docs/templates.md#stringify-type
专指删去了 color label 的 [[Template]]

本质上是一个隐式转换，在我们的代码逻辑中，应该直接把它看成是 Template 的 alias

*** Trailer
https://github.com/jj-vcs/jj/blob/main/docs/templates.md#trailer-type

这应该是一个挺重要的类型，表示一种数据结构

* Functions
除了原生的模板语言的内置函数，我还希望能定义一些用宏实现的自定义函数（或方法）

需要支持返回值作为它作为其他函数参数时的类型

** 原语 raw
仅有 ~[:raw "string"]~ 为 [[raw]] type

语法糖 ~'string~ => ~[:raw "string"]~

*** 类型声明
现在仅支持 ~[:raw "string" :Template]~

TODO: ~[:Template "string"]~ => ~[:raw "template" :Template]~

** 模板函数
一种是全局的函数
一种是对象的方法

调用分为三层
1. 内置函数/方法
2. 自定义的模板函数/方法
   这正是我们的设计的强大之处
3. fallback (可配置 警告加+raw / 直接报错)
TODO: 目前实现直接抛错，缺少其他 fallback 模式

需要做到共享语法的同时实现宏展开
可以看成一个自展开的宏
递归编译

如何处理参数？
我觉得直接复制一遍不太对
因为它真的可能出现很多很多次

应该在作为参数的那些叶子上设置上指向传入值的引用（节点的 hash 值）
他们应该只需要编译一次，然后之后就直接复制raw

** 函数调用
一般来说可写为 ~[:FUN args]~

~[:call 'builtin args]~
=> ~[:raw "builtin(arg1, arg2, ...)"]~

** 方法调用
~[:method 'OBJ :FUN args]~

连续调用：
~[:method 'OBJ :FUN1 arg1 arg2 ... :FUN2 args2]~
要能支持 &arg 的多参数收集，当然是取到下一个 :FUN 前

~:.~ 应该被认为等同于 ~:method~

*** self keyword 语法糖
关键字是对于 self 对象的 0 参数 方法的简化写法
相当于可以省去 self. 和 ()

这个语言本来提供了一个不用方法而用关键字的语法糖，我认为这个语法糖还不够彻底
（函数定义里没有这个功能，只有命令直接调用的时候有）

对于 ~[:FUN]~
- 如果 :FUN 是全局、内置函数，就给全局函数
- 如果 :FUN 是 self 对象类型的0参数方法，直接扩展为 ~[:method 'self :FUN]~
  我们默认一个函数的第一个参数是 self 变量
  我们需要替换成的是 self 变量对应的字面值，不是直接替换成 'self
- 如果都不是，报错，提示找不到 OBJ

我们可以把关键字体现在字面量上
比如说对于 ~'change_id~ 我们完全可以先尝试让他作为 ~[:change_id]~ 的形式看看能不能匹配成关键字
（前两步一致，最后一步是用无类型的 raw 为 fallback，当然警告也要警告）
TODO: 目前这个功能未实现

NOTE: 目前只能匹配显式标记为 keyword 的方法，普通 0 参数方法需使用 :method
这是为了更好的语义，之后可能可以考虑自动将0参数方法标记为 keyword

** concat 语法糖
~["X" "Y"]~ => ~[:concat "X" "Y"]~
这里要求向量中的每一项都能转换为 Template
一般来说只需要看第一项的类型就行

也支持把 ~:concat~

另外也可以用 ~:concat-op~ 和 ~:++~，他们表示的是编译后要不要使用 ~Part1 ++ Part2~ 等同于 ~concat(Part1,Part2)~ 的语法糖，得到的效果是相同

** List related
文档中 List 对象有下面四个特殊函数

~.filter(|item| expression) -> List~: Filter list elements by predicate
 `expression`. Example: `description.lines().filter(|s| s.contains("#"))`
 
~.map(|item| expression) -> ListTemplate~: Apply template `expression`
 to each element. Example: `parents.map(|c| c.commit_id().short())`
 
~.any(|item| expression) -> Boolean~: Returns true if any element satisfies
 the predicate `expression`. Example: `parents.any(|c| c.description().contains("fix"))`
 
~.all(|item| expression) -> Boolean~: Returns true if all elements satisfy
 the predicate `expression`. Example: `parents.all(|c| c.mine())`
 
正常的 ~:map~ 和一般的成员函数无异，可以使用
接受的变量是 item EXPRESSION
会被处理为正确的格式，item 变量不用给 | 符号，传的是 symbol

*** 匿名函数 with binding
还是需要支持绑定参数的形式，不然不好嵌套
TODO: 此部分的所有语法糖都尚未实现

使用 - 开头的函数表示支持形似 ~(-map FN LIST)~ 的语法

这和前面定义的 OBJ 前置有点不一样，
但是为了和 elisp 的统一，我觉得有必要搞一个反序的形式
TODO: :-map 等语法糖尚未实现

一个例子
~[:-map [:lambda [c] [:method 'c :description]] [:added_targets]]~
=> ~[:method [:added_targets] :map [:lambda [c] [:method 'c :description]]]~

注意这里不能省略 :method ，因为这里父亲的 self 对象依然存在！
只有完全单独定义的函数可以应用这个语法糖

*** 匿名函数 without binding
一些简单的函数就不需要写 binding 了
可以完美对应上
fn:--map
fn:--filter
fn:--any
fn:--all-p
TODO: Dash 风格 :--map/:--filter 等尚未实现

例子：
~[:--map [:method 'it :description] [:added_targets]]~

** 自定义函数
*** 定义宏
宏 ~majutsu-template-defun~ 会在定义阶段完成两件事：
1. 生成一个 ~majutsu-template-NAME~ 的 Elisp 函数，调用前会先对参数做 normalize（向量 → AST、字符串 → ~:str~），再执行主体，最后再 normalize 返回值。
2. 同时把函数的元数据写入注册表：
   读取参数列表 ~(:returns TYPE …)~

参数声明使用 ~(arg TYPE [:optional t] [:rest t] [:converts LIST])~ 形式；宏在宏展开期解析这些信息，自动拼好 ~lambda-list~ 与 docstring。

方法/关键字可以通过 ~majutsu-template-defmethod~、~majutsu-template-defkeyword~ 封装，或在常量表里批量声明。

*** 匿名函数
~[:lambda [c] BODY]~
作为参数的时候它可以转成 ~[[:raw "|c| "] BODY]~
TODO: Lambda 语法目前未提供

或多变量的形式
~[:lambda [a b c] BODY]~
我觉得可能不太好处理，可能之后再支持

一般来说单个变量的用的比较多
设置一个 ~[:|ARG| BODY]~ 的语法糖，这更加符合原本的语法
相当于 ~[:lambda [ARG] BODY]~

需要一个和 :call 配合的语法糖
~[[:lambda [c] BODY] arg]~
等效于
~[:call [:lambda [c] BODY] arg]~

*** 函数元数据
**** flavor
[[file:~/.config/emacs/.local/straight/repos/majutsu/majutsu-template.el::(cl-defstruct (majutsu-template--fn-flavor][fn-flavor]]
 
我们可以把函数的模式定义和函数定义分开

一个 flavor 包含哪些元数据？
然后推荐是正常情况下手动把 orgs returns owner 写满，body 继承来是意料之中的

一个函数的元数据可选地可以在一个 flavor 的基础上覆盖（未指定就是 :custom）
也就是继承！
应该继承那些信息？应该是所有信息
owner args returns builder

有 flavor 的定义函数 [[file:~/.config/emacs/.local/straight/repos/majutsu/majutsu-template.el::defun majutsu-template-define-flavor (name &rest plist][define-flavor]]

:builtin
[:FUN [optional: OBJ] NAME ARGS] => Template
根据是否有 owner 输出 fun(arg, ...) 或 obj.fun(arg, ...)

:filter-like
[:FUN OBJ item BODY] => List
强制有 :owner

:map-like
[:FUN OBJ item BODY] => ListTemplate
强制有 :owner

:-map-like
[:-map LAMBDA OBJ] => ListTemplate
强制有 :owner

:--map-like
[:--map -LAMBDA OBJ] => ListTemplate
强制有 :owner
这里的 -LAMBDA 表示的是用 it 直接替代传入参数的匿名函数

:custom
完全自己定义，不继承任何 fn-flavor 信息
这里可以用来做一些语法糖的实现
我们的 :-lambda :lambda :+ARG 就可以定义在这里
我暂时不知道 :+ARG 应该如何处理。。。

:fn
[:FUN [optional: OBJ] NAME ARGS] => Template
这是我们的默认的函数模板宏，需要自己写 body
和 :custom 的区别在于加了一个advice
如果有 :owner 字段，自动添加 OBJ 作为第一个参数

继承自 :custom （这个继承需要把对应的参数传下来，包括 builder, 我们以此实现 advice）
TODO: flavor 的继承目前只有简单的实现，目前只是在向上找第一个非空的 body

**** ~majutsu-template--fn~ 字段

(name doc flavor owner args returns body)

name: 函数名
doc: docstring
flavor: 继承的 fn-flavor
owner: 用来得到所属类型信息，也可能用来操控参数列表
args: 参数列表及对应类型
returns: 返回值
body: 函数的具体行为，能根据元数据做一些操作

*** 顶层函数
使用 ~majutsu-template-defun~ 定义模板函数时，宏会同时生成 Elisp 实现与元数据；在 ~majutsu-template.el~ 内置函数也通过常量表注册。

类型签名写为 ~(:returns TYPE ...)~；
额外的 [:owner] 只在方法/关键字定义时需要，keyword 与 method 共享同一注册表。
方法和关键字使用 ~majutsu-template-defmethod~ / ~majutsu-template-defkeyword~，或者在常量 ~majutsu-template--builtin-method-specs~ 里声明；
都会展开成带 self 的参数列表并登记类型。
默认情况下，以 ~majutsu-template-defmethod~ 定义的 0 参数方法不会被视为 keyword，
不会触发 ~[:name]~ 语法糖；若要参与 keyword 重写，需要在签名中显式添加 ~:keyword t~，
或直接使用 ~majutsu-template-defkeyword~ 宏。
内建类型通过 ~majutsu-template-define-type~ 录入，含 ~:doc~ 与 ~:converts~ 信息；支持 ~((Type . status))~、符号或列表等多种写法，宏会统一成 `(TYPE . (yes|no|maybe))`。

**** ~majutsu-template--arg~

字段含义：
~name~（形参符号）
~type~（期望的模板类型）
~optional~（非 nil 表示对应 &optional 参数）
~rest~（非 nil 表示这是 &rest 参数）
~converts~（额外允许的隐式转换声明）
~doc~（参数说明文字）

宏会使用这些信息生成 docstring，并在未来的类型检查阶段判断参数是否符合签名。

**** ~majutsu-template--type~
字段含义：
~name~（类型符号）
~doc~（说明文字）
~converts-to~（列表，记录到 Boolean/Serialize/Template 等目标类型的可转换状态，取值 ~yes~/~no~/~maybe~）

内建类型由 ~majutsu-template-define-type~ 注册，后续类型推断会参考这张表确定隐式转换是否合法。

* 嵌入 Emacs Lisp
这是非常重要的功能
TODO: 目前仅支持基本的宏期 eval，复杂场景仍需实现

** 直接嵌入
直接嵌入的 consp 形式需要在宏展开时运行

比如：
~[(if t "A" "B") (if t "C" "D")]~
我想要得到的是
~[:concat "A" "C"]~

** 反引号插入
回引号 + 逗号插入已计算的节点：
#+begin_src emacs-lisp
(let ((name (majutsu-template-str (user-full-name))))
  (tpl-compile `[:concat ,name [:str ": "] [:raw "self.commit_id()"]]))
#+end_src
    
批量插入：
#+begin_src emacs-lisp
(let ((items (mapcar #'majutsu-template-str '("A" "B"))))
  (tpl-compile `[:concat ,@items]))
#+end_src
    
* 哪些命令的输出可以使用 template ?
| command        | self type            |
|----------------+----------------------|
| bookmark list  | CommitRef            |
| diff           | TreeDiffEntry        |
| evolog         | CommitEvolutionEntry |
| file annotate  | AnnotationLine       |
| flie list      | TreeEntry            |
| flie show      | TreeEntry            |
| log            | Commit               |
| op log         | Operation            |
| op show        | Operation            |
| show           | Commit               |
| tag list       | CommitRef            |
| workspace list | WorkspaceRef         |
| config list    | [[config list template]] |

** config list template
我们可以因此建一个 Config type

name: String: Config name.
value: ConfigValue: Value to be formatted in TOML syntax.
overridden: Boolean: True if the value is shadowed by other.
source: String: Source of the value.
path: String: Path to the config file.

* AST
** 节点定义
语法树节点定义在这里 [[file:~/.config/emacs/.local/straight/repos/majutsu/majutsu-template.el::(cl-defstruct (majutsu-template-node][node]]

节点信息：
kind: 在 elisp 视角下的类型
type: template 视角下的类型
value: 值
args: 各个参数的 ast node
props: 其余属性

*** :kind
有 :literal :raw :call 三种类型

:literal 对应的是需要被转换为字符串的信息
这里不和 raw 合并是因为在 str-escape 会修改 :value
而我们一般是希望它们在 ast 阶段保持统一的

:raw 就是直接插入的 :value

:call 比较特殊，它是延迟求值的语法树
在得到它之后还需要继续运行 majutsu-template-call

*** :props
重要的信息有：
当前命名空间中的变量及其类型
self 对象

** 解析步骤

*** 摘除所有嵌入的 elisp

,(...)
,@(...)
(...)

elisp 嵌入显然是可以在一开始消除的

*** 语法糖展开
我们大部分的语法糖是通过 custom flavor 的函数实现的
但是对于一些结构层次语法糖就需要特殊处理一下
比如 t -> true
比如裸 vector 对应的 concat

*** 模板宏调用
调用的本质其实是
给对应变量新的绑定
用当前的 elisp 环境变量

我把这个步骤放在了延迟求值的 :call node 上
