#+title: Majutsu 模板封装规范（v1）

* 范围
- 本文是 majutsu-template EDSL 的权威规范，约束构造器、语法糖与实现行为。
- 任何实现细节（编译器、宏、测试）必须与本文件保持一致；参考文档是解释材料，不具约束力。

* 设计目标
- 提供一个小而可组合的 Elisp EDSL，将表达式编译为 jj 模板语言字符串。
- 保证所有生成内容默认安全：统一字符串转义，显式区分原样注入。
- 鼓励稳定输出格式，利于 JSON/结构化消费与单元测试。

* 类型系统
** 对象方法
- 模板中的对象只能调用在类型签名表中列出的 0 参数或指定参数的方法。
- 方法调用在宏展开期仅做静态检查（方法名、实参个数、字面量类型），其余语义由 jj 运行期负责。

** Conversion
- 仅允许隐式转换到三种目标类型：Boolean、Serialize、Template。
- 每个构造器或方法声明应同时登记“输出可转换类型”集合，用于在宏层面做快速验证。
- 若某类型既不在转换表内，也未显式标注为 Template，应在编译期抛错以避免生成非法模板。

** 实现细节
- EDSL 的根节点类型记为 Template；其它类型通过转换表折叠为 Template/Serialize/Boolean。
- 当函数的返回类型需要在上游作为参数继续推断时，必须将其声明为结构化节点而非立即降级成 raw 字符串。


** 内部类型
* AST 节点与基础构造器
- 内部 AST 统一采用 plist：~(:tag ...)~。允许的 tag 集合：~:str~、~:raw~、~:call~、~:method~、~:op~、~:map~、~:filter~、~:any~、~:all~、~:join~。
- 对外暴露以下构造器（函数均位于 majutsu-template 命名空间）：
  - ~majutsu-template-str STRING~：创建字符串字面量（自动转义双引号、反斜杠、换行、制表符、回车、NUL、ESC）。
  - ~majutsu-template-raw STRING~：原样注入，供熟悉 jj 模板语法的调用者使用。
  - ~majutsu-template-call NAME &rest ARGS~：一般函数调用。
  - ~majutsu-template-concat &rest FORMS~：~concat(...)~ 语义。
  - ~majutsu-template-if COND THEN &optional ELSE~：~if(...)~ 语义（ELSE 省略时不生成第三个实参）。
  - ~majutsu-template-label NAME VALUE~：~label(NAME, VALUE)~，NAME 自动转成字符串。
  - ~majutsu-template-separate SEP &rest FORMS~：~separate(...)~。
  - ~majutsu-template-surround PRE POST BODY~：~surround(...)~。
  - ~majutsu-template-json FORM~：~json(FORM)~。
  - ~majutsu-template-join SEP COLL VAR BODY~：等价于 ~COLL.map(|VAR| BODY') .join(SEP)~，其中 ~VAR~ 必须为符号；宏使用该符号作为闭包参数，并在 ~BODY~ 中允许通过 ~'VAR~（或其它基于 ~VAR~ 的表达式）引用该参数；返回 ~:join~ 节点。

* 宏语法
** 方括号规则
- 所有宏输入（~tpl~、~tpl-compile~）必须是向量，且嵌套层级同样只能使用向量。普通列表 ~(...)~ 在语法分析阶段一律报错。
- 允许传入已构造好的 AST（plist 以 ~:tag~ 开头），宏应将其视为原子。

** 隐式 concat
- 若向量首元素不是关键字或符号，整体按 ~[:concat ...]~ 处理。
- 向量中的裸字符串自动视作 ~[:str ...]~，避免重复书写。

** 字符串与 quote
- 字符串字面量统一用双引号包裹，转义规则见 ~majutsu-template-str~。
- ~'symbol~ 语法糖视作 ~[:raw "symbol"]~；~'"string"~ 视作 ~[:str "string"]~。
- 其它 ~(quote ...)~ 形式一律报错，避免误将列表当作模板片段。
- ~[:raw EXP]~ 会在宏期求值 ~EXP~，并要求结果为字符串（或可解析为字符串的字面节点）；否则抛错。

** 函数与方法调用
- ~[:call CALL-NAME arg1 arg2 ...]~ 与 ~[:CALL-NAME arg1 arg2 ...]~ 同源：
  - 若 ~CALL-NAME~ 是字符串、符号或关键字，则直接作为模板函数名。
  - 若 ~CALL-NAME~ 为 ~[:str ...]~/~[:raw ...]~ 等字面量节点，解析取其字符串值。
  - 若表达式被 `tpl`/`tpl-compile` 包裹并且在宏阶段可计算（例如 `(if ...)`），则先求值再按上述规则解析。
  - 若宏期仍无法得知函数名（例如 ~[:raw (if ...)]~），会抛错提醒调用者显式给出字面量。
- ~[:method OBJ method a b ...]~ 生成 ~:method~ 节点并允许链式展开：~[:method OBJ method1 arg1 :method method2]~ 需被规范化为顺序方法调用。
- ~:.~ 是 ~:method~ 的别名。
- 方法名、函数名必须为符号或字符串字面量；禁止在宏语法中通过求值产生。

** 运算符
- 所有算术、比较、逻辑、模运算使用关键字表示：~:+~、~:-~、~:*~、~:/~、~:%~、~:>=~、~:>~、~:<=~、~:<~、~:==~、~:!=~、~:and~、~:or~、~:not~、~:neg~、~:concat-op~。
- 运算符会生成 ~:op~ 节点，并在最终编译时统一加括号，避免优先级歧义。

** 集合构造器
- ~[:map COLL VAR BODY]~、~[:filter COLL VAR BODY]~、~[:any COLL VAR BODY]~、~[:all COLL VAR BODY]~ 必须生成对应的 ~:map~/~:filter~/~:any~/~:all~ 节点。~VAR~ 必须为符号（不执行求值）；宏将其拼接进闭包 ~|VAR|~，并允许在 ~BODY~ 中通过 ~'VAR~ 或 ~[:raw "VAR"]~ 等形式引用该变量。
- ~[:join SEP COLL VAR BODY]~ 是 ~:join~ 的语法糖，最终依赖 ~majutsu-template-join~；~VAR~ 与 ~BODY~ 的处理规则与 ~:map~ 保持一致。
- 所有集合节点的 ~COLL~ 与 ~BODY~ 均按模板表达式处理；宏阶段不得强制将其降级为字符串。

** 禁用特性
- 语法中禁止出现 ~:lit~、~:raw-e~ 或其它“直接求值再注入”的构造。
- 除 “直接嵌入” 小节描述的整项表达式处理外，宏不得对用户传入的 Lisp 表达式求值。

* List 与 ListTemplate
- ~List~ 类型可调用 ~.len()~、~.join()~、~.filter()~、~.map()~、~.any()~、~.all()~；其布尔语义表示“是否为空”。
- ~List.map()~ 产物是 ~ListTemplate~，只能继续 ~.join()~；规范要求在宏层面显式区分两种节点，避免误用。
- 处理 ~.map(|item| expression)~ 时，宏直接使用显式的 ~item~ 符号建立闭包。调用者可在 ~expression~ 中通过 ~'item~（或其它依赖该符号的语法糖）引用当前元素，同时仍能在需要时使用自定义函数封装共享逻辑。

* 与 Emacs Lisp 配合
** 直接嵌入
- 向量中的字面量 Lisp 表达式会在宏展开期求值，再根据结果自动转换为节点：
  - 字符串 → ~:str~
  - 预构建 AST → 原样使用
  - 其它类型触发编译期错误
- 若遇到 cons 结构（如 ~(:foo ...)~ 或 ~(if ...)~），会在宏期先求值，再将结果回填至原位置；结果继续按上述规则归一化。
- 示例：~[(if "A" "B") (if t "C" "D")]~ 在宏展开后等价于 ~[:concat "A" "C"]~。

** 反引号插入
- 推荐使用 ~`[...]~ 配合 ~,~/~,@~ 注入提前构造好的节点或向量片段。
- 宏接受预构建节点（car 为关键字，如 ~:str~），便于在普通函数中先组合再统一编译。

** 复用与封装
- 构造器都是普通函数，可与 ~if~/~when~/~pcase~ 等 Lisp 控制流组合后再交给 ~majutsu-template-compile~。
- 对常见片段（如 JSON 行、书签列表）提倡封装成返回 AST 的 helper 函数，最终由调用者决定何时编译。

* 逆向解析
- 编译器应保留足够的结构信息，允许调用方在需要时对 AST 进行逆向分析（例如匹配 map/join 模式）。
- 简单场景下，可通过访问 ~:tag~ 与字段提取参数；无需实现完整的反向编译。

* 自定义函数
** 定义宏 ~majutsu-template-defun~
语法：
#+begin_src emacs-lisp
(majutsu-template-defun NAME ((ARG TYPE &rest OPTIONS) ...)
                        (:returns RETURN-TYPE [:converts (TYPE ...)] [:doc DOCSTRING])
                        BODY)
#+end_src
  
- ~NAME~ 必须是未带前缀的符号；宏会生成 `majutsu-template-NAME` 函数并自动注册，使其可在模板 DSL 中通过 ~[:call 'NAME ...]~、~[:call "NAME" ...]~ 或 ~[:NAME ...]~ 调用。若 ~NAME~ 与内置函数、已有别名或已注册自定义函数冲突，应在定义阶段抛错。
- 每个参数规格为列表：(符号 类型 [选项])：
  - ~类型~ 为核心类型名（~Boolean~、~Template~、~Serialize~ 或领域类型如 ~Commit~、~ListTemplate~ 等），表示静态期望的模板值类型。
  - 支持选项：
    - ~:optional t~：标记可选参数；签名表会记录最小/最大实参个数。
    - ~:rest t~：最后一个参数收集剩余实参；签名记录实参类型集合。
    - ~:converts (TYPE1 TYPE2 ...)~：允许调用时接受其它类型并隐式转换为~类型~。
    - ~:doc STRING~：针对单个参数的文档，合并到生成的函数文档中。
- ~:returns~ 指定主返回类型；可选的 ~:converts~ 列表声明返回值还能隐式转换成哪些类型，以支撑后续调用的类型检查。
- ~:doc~ 为整体函数文档，写入 `majutsu-template-NAME` 的 docstring，并用于开发者文档生成。
- ~BODY~ 必须产生 AST（推荐使用向量语法）。宏在展开时会调用 ~majutsu-template--sugar-transform~ 将其归一化，并缓存结果。

** 参数绑定与占位符
- 宏在展开时为每个参数生成局部符号，并通过 `let` 引入；函数实现内使用同名符号表示已归一化的 AST。
- 若 ~BODY~ 需要把参数插入模板表达式，使用反引号配合逗号，如：

#+begin_src emacs-lisp
(majutsu-template-defun example ((label Template) (value Template :optional t))
  (:returns Template)
  `[:concat ,label [:str ": "] ,(or value [:str ""])])
#+end_src
** 注册与类型检查
- 宏需要更新全局签名表：NAME → 参数列表（包含类型、可选/可变参数信息）。
- 同时更新返回类型表：NAME → 主返回类型 + 可转换集合。
- 当 ~[:call 'NAME ...]~ 或 ~[:NAME ...]~ 出现在模板中时，静态检查阶段将参考签名表校验实参：
  - 实参数量是否符合区间。
  - 每个实参的类型是否与声明匹配或在 ~:converts~ 列表中。
- 若检查失败，宏应抛出 ~user-error~，并给出清晰提示（函数名、期望类型、实际类型）。
- 重新定义同名函数会覆盖旧记录，并通过 ~message~ 提醒开发者（方便调试）。

** 运行时行为
- 生成的 `majutsu-template-NAME` 函数返回 AST，可在任意 Elisp 代码中组合、再经 ~majutsu-template-compile~ 输出最终模板字符串。
- 函数实现应调用内部归一化辅助（如 ~majutsu-template--normalize~）确保所有实参统一成 AST，然后再与 ~BODY~ 组合。
- 可选/可变参数在缺省时需主动抛出错误或提供默认值，避免生成语义不完整的模板。
- 如需包装外部 jj 模板函数，可在 ~BODY~ 中直接返回 ~[:call 'external ...]~ 节点，或使用 ~[:external ...]~ 语法糖。

** 示例
定义格式化片段：
#+begin_src emacs-lisp
(majutsu-template-defun format-field ((label Template)
                                      (value Template :optional t))
  (:returns Template :doc "Label/value on one line.")
  `[:concat ,label [:str ": "] ,(or value [:str ""])])
#+end_src

- 在模板中使用：~(tpl-compile [:call 'format-field [:str "ID"] (:raw "commit_id")])~ 或直接 ~[:format-field [:str "ID"] (:raw "commit_id")]~。
- 类型系统会根据签名自动允许省略第二个参数，并把返回类型视为 Template，从而可以继续传给其他期望 Template 的构造器。

* 测试建议
- 为每个构造器、算子与语法糖编写 ERT 单元测试，确保输出稳定。
- 针对代表性模板（日志行、JSON Lines）编写快照测试。
- 新增方法或类型签名时，应补充静态检查失败路径的测试用例。

* 安全注意事项
- ~majutsu-template-raw~ 是最后手段，应在评审中明确使用理由。
- 包含换行或潜在特殊字符的字段，应优先使用 ~json(...)~ 或 ~.escape_json()~，在 Emacs 端解析结构化数据。
- 模板中出现的外部输入要在进入 EDSL 前完成校验，避免在 raw 注入阶段留下攻击面。
